

I could represent shapes in a 1d array (shape1d), with the blocks represented with value 1;

then I could find the lowest location the shape's center-block could go;
from there loop in the table in a range 'shape1d' and look if theres's a block in the table at the position of the block in 
the shapeId. 
If there is, move up the center block and repeat.

cw j  =  010010110 100111000 011010010 000111001
ccw j =  010010110 000111001 011010010 100111000

cw l  = 010010011 000111100 110010010 001111000
ccw l = 010010011 001111000 110010010 000111100

cw t  =  010111000 010011010 000111010 010110010
ccw t =  010111000 010110010 000111010 010011010

cw s  = 011110000 010011001 000011110 100110010
ccw s = 011110000 100110010 000011110 010011001

cw z  = 110011000 001011010 000110011 010110100
ccw z = 110011000 010110100 000110011 001011010

cw i  = 0100010001000100 0000111100000000 0010001000100010 0000000011110000
ccw i = 0100010001000100 0000000011110000 0010001000100010 0000111100000000

[0, 1, 0, 0]   [0, 0, 0, 0]     [0, 0, 1, 0]    [0, 0, 0, 0]
[0, 1, 0, 0]   [1, 1, 1, 1]     [0, 0, 1, 0]    [0, 0, 0, 0]
[0, 1, 0, 0]   [0, 0, 0, 0]     [0, 0, 1, 0]    [1, 1, 1, 1]
[0, 1, 0, 0]   [0, 0, 0, 0]     [0, 0, 1, 0]    [0, 0, 0, 0]








find the '-': rot_state * 9 * (clockwise ? 1 : 2)



[0, 0, 0]
[0, 0, 0]
[0, 0, 0]




































































































// if (block_idx == cb_idx){ // almost works
//    block_idx++;
//    continue;
// }











  // rotate(matrix, table, ctx){
    // if (this.docked) return;

    // if (this.type == 'O') return;

    // Center Block 
    // let cb_idx = this.rot_state < 3 ? 1 : 2;
    // let cbx = this.blocks[cb_idx].x;
    // let cby = this.blocks[cb_idx].y;
    // matrix[1][1] = 1 

    // ctx.fillStyle = 'black';
    // ctx.fillRect((this.blocks[cb_idx].y * BLOCK_SIZE) + 25, (this.blocks[cb_idx].x * BLOCK_SIZE) + 25, BLOCK_SIZE, BLOCK_SIZE);

    // ctx.fillStyle = 'blue';
    // ctx.globalAlpha = 0.5;
    // ctx.fillRect((cby - 1) * BLOCK_SIZE + 25, (cbx - 1) * BLOCK_SIZE + 25, BLOCK_SIZE * 3, BLOCK_SIZE * 3);

    // Block's coords in Matrix
    // let mbx = 0;  
    // let mby = 0;

    // translate into matrix
    // for (let i = 0; i < this.blocks.length; i++){
      // let b = this.blocks[i];

      // if (b.x > cbx) mbx = 2; 
      // else if (b.x == cbx) mbx = 1;

      // if (b.y > cby) mby = 2;
      // else if (b.y == cby) mby = 1;

      // matrix[mbx][mby] = 1;
      // mbx = 0;
      // mby = 0;
    // }

    // rotate in CLOCKWISE direction 
    // let l = 0;
    // let r = matrix.length - 1;

    // while (l < r){
      // for (let i = 0; i < r - l; i++){
        // let _top = l; // top is a regular keyword
        // let bot = r;

        // let top_l = matrix[_top][l + i];
        // matrix[_top][l + i] = matrix[bot - i][l];
        // matrix[bot - i][l] = matrix[bot][ r - i];
        // matrix[bot][r - i] = matrix[_top + i][r];
        // matrix[_top + i][r] = top_l;
      // }   
      // r--;
      // l++;
    // }

    // this.unload_from_table(table);

    // avoid blocks going out of hor boundaries
    // if (cby == 0) cby++;
    // else if (cby == ROWS - 1) cby--;
    
    // translate back into table
    // let block_idx = 0;

    // const _cb = this.blocks.splice(cb_idx, 1);

    // for (let i = 0; i < 9; i++){
      // let k = Math.floor(i / 3);
      // let j = i % 3;

      // if (block_idx == cb_idx){
        // console.log('aaaaaaaaaaaaa', block_idx);
        // continue;
      // }

     // if (matrix[k][j] == 1){
        // if (k == 0) this.blocks[block_idx].x = cbx - 1;
        // else if (k == 1) this.blocks[block_idx].x = cbx;
        // else this.blocks[block_idx].x = cbx + 1;
        
        // if (j == 0) this.blocks[block_idx].y = cby - 1;
        // else if (j == 1) this.blocks[block_idx].y = cby;
        // else this.blocks[block_idx].y = cby + 1;

        // block_idx++;
      // }
    // }
    
    // this.rot_state = this.rot_state < 4 ? this.rot_state + 1 : 1;
    // this.blocks.splice(this.rot_state < 3 ? 1 : 2, 0, _cb[0]);
    // this.load_on_table(table);
    // this.allow_rot = false;
  // }





























